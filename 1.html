<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HaiCalling - Realtime Communication</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; display: flex; flex-direction: column; align-items: center; background-color: #f0f2f5; }
        .container { max-width: 1000px; width: 100%; background: #fff; box-shadow: 0 0 10px rgba(0,0,0,0.1); margin-top: 20px; }
        .header { background-color: #4a90e2; color: white; padding: 15px; text-align: center; font-size: 24px; }
        .main-content { display: flex; }
        .video-container { width: 60%; padding: 20px; border-right: 1px solid #ddd; }
        .chat-container { width: 40%; padding: 20px; display: flex; flex-direction: column; }
        #videos { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; background: #000; padding: 10px; border-radius: 8px; }
        video { width: 100%; border-radius: 5px; }
        .controls { text-align: center; margin-top: 15px; }
        button { background-color: #4CAF50; color: white; padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; margin: 5px; }
        button:hover { background-color: #45a049; }
        button#hangupBtn { background-color: #f44336; }
        button#hangupBtn:hover { background-color: #da190b; }
        #chat-messages { flex-grow: 1; border: 1px solid #ccc; border-radius: 5px; padding: 10px; margin-bottom: 10px; overflow-y: auto; height: 400px; }
        #chat-form { display: flex; }
        #message-input { flex-grow: 1; border: 1px solid #ccc; padding: 10px; border-radius: 5px; }
        #call-id-input { padding: 10px; border: 1px solid #ccc; margin-bottom: 10px; width: calc(100% - 22px); }
    </style>
</head>
<body>

    <div class="container">
        <div class="header">HaiCalling</div>
        <div class="main-content">
            <div class="video-container">
                <h2>Video Call</h2>
                <div id="videos">
                    <video id="localVideo" muted autoplay playsinline></video>
                    <video id="remoteVideo" autoplay playsinline></video>
                </div>
                <div class="controls">
                    <input type="text" id="call-id-input" placeholder="Enter Call ID to start or join a call">
                    <button id="startCallBtn">Start Call</button>
                    <button id="hangupBtn">Hang Up</button>
                </div>
            </div>
            <div class="chat-container">
                <h2>Real-time Chat</h2>
                <div id="chat-messages"></div>
                <form id="chat-form">
                    <input type="text" id="message-input" placeholder="Type a message..." required>
                    <button type="submit">Send</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>

    <script>
        // --- FIREBASE CONFIGURATION ---
        // PASTE YOUR FIREBASE CONFIG HERE
        const firebaseConfig = {
          apiKey: "AIzaSyAD2S8b5dxYV1fFYc-RMJMwV1IQ3yCRvd0",
          authDomain: "haicalling.firebaseapp.com",
          databaseURL: "https://haicalling-default-rtdb.asia-southeast1.firebasedatabase.app",
          projectId: "haicalling",
          storageBucket: "haicalling.firebasestorage.app",
          messagingSenderId: "379823659600",
          appId: "1:379823659600:web:d86fb74951ce52206b4f55"
        };

        // --- INITIALIZE FIREBASE ---
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        // --- CHAT FUNCTIONALITY ---
        const chatForm = document.getElementById('chat-form');
        const messageInput = document.getElementById('message-input');
        const chatMessages = document.getElementById('chat-messages');

        // Listen for new messages
        db.collection('messages').orderBy('createdAt').onSnapshot(snapshot => {
            chatMessages.innerHTML = '';
            snapshot.forEach(doc => {
                const message = doc.data();
                const messageElement = document.createElement('div');
                messageElement.textContent = message.text;
                chatMessages.appendChild(messageElement);
            });
            chatMessages.scrollTop = chatMessages.scrollHeight;
        });

        // Send a message
        chatForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const text = messageInput.value;
            if (text.trim() !== '') {
                db.collection('messages').add({
                    text: text,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                messageInput.value = '';
            }
        });

        // --- VIDEO & VOICE CALL FUNCTIONALITY (WebRTC) ---
        const startCallBtn = document.getElementById('startCallBtn');
        const hangupBtn = document.getElementById('hangupBtn');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const callIdInput = document.getElementById('call-id-input');

        let localStream;
        let remoteStream;
        let peerConnection;
        
        const servers = {
            iceServers: [
                { urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] },
            ],
            iceCandidatePoolSize: 10,
        };
        
        startCallBtn.onclick = async () => {
            const callId = callIdInput.value;
            if (!callId) {
                alert('Please enter a Call ID to start or join a call.');
                return;
            }
            
            // Get local media
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            localVideo.srcObject = localStream;

            peerConnection = new RTCPeerConnection(servers);
            
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            remoteStream = new MediaStream();
            peerConnection.ontrack = event => {
                event.streams[0].getTracks().forEach(track => {
                    remoteStream.addTrack(track);
                });
                remoteVideo.srcObject = remoteStream;
            };

            const callDoc = db.collection('calls').doc(callId);
            const offerCandidates = callDoc.collection('offerCandidates');
            const answerCandidates = callDoc.collection('answerCandidates');

            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    offerCandidates.add(event.candidate.toJSON());
                }
            };
            
            const offerDescription = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offerDescription);

            const offer = {
                sdp: offerDescription.sdp,
                type: offerDescription.type,
            };

            await callDoc.set({ offer });

            // Listen for remote answer
            callDoc.onSnapshot(async (snapshot) => {
                const data = snapshot.data();
                if (!peerConnection.currentRemoteDescription && data?.answer) {
                    const answerDescription = new RTCSessionDescription(data.answer);
                    await peerConnection.setRemoteDescription(answerDescription);
                }
            });

            // Listen for ICE candidates
            answerCandidates.onSnapshot(snapshot => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === 'added') {
                        const candidate = new RTCIceCandidate(change.doc.data());
                        peerConnection.addIceCandidate(candidate);
                    }
                });
            });

            hangupBtn.disabled = false;
        };

        // This would be the 'join call' logic, but we simplify it here.
        // If a call with the ID exists, this will act as the 'answerer'.
        // For a real app, you would separate 'create' and 'join' logic.
        db.collection('calls').onSnapshot(snapshot => {
            snapshot.docChanges().forEach(async (change) => {
                if (change.type === 'added') {
                    const callId = change.doc.id;
                    if (callId === callIdInput.value && !peerConnection) {
                        // This logic is for the joining user
                        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                        localVideo.srcObject = localStream;

                        peerConnection = new RTCPeerConnection(servers);

                        localStream.getTracks().forEach(track => {
                            peerConnection.addTrack(track, localStream);
                        });

                        remoteStream = new MediaStream();
                        peerConnection.ontrack = event => {
                            event.streams[0].getTracks().forEach(track => {
                                remoteStream.addTrack(track);
                            });
                        };
                        remoteVideo.srcObject = remoteStream;

                        const callDoc = db.collection('calls').doc(callId);
                        const offerCandidates = callDoc.collection('offerCandidates');
                        const answerCandidates = callDoc.collection('answerCandidates');
                        
                        peerConnection.onicecandidate = event => {
                            if (event.candidate) {
                                answerCandidates.add(event.candidate.toJSON());
                            }
                        };
                        
                        const callData = (await callDoc.get()).data();
                        const offerDescription = callData.offer;
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(offerDescription));

                        const answerDescription = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answerDescription);

                        const answer = {
                            type: answerDescription.type,
                            sdp: answerDescription.sdp,
                        };

                        await callDoc.update({ answer });

                        offerCandidates.onSnapshot(snapshot => {
                            snapshot.docChanges().forEach(change => {
                                if (change.type === 'added') {
                                    let data = change.doc.data();
                                    peerConnection.addIceCandidate(new RTCIceCandidate(data));
                                }
                            });
                        });
                    }
                }
            });
        });

        hangupBtn.onclick = () => {
            if (peerConnection) {
                peerConnection.close();
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            // You might want to also clean up the call document in Firestore
        };

    </script>
</body>
</html>
